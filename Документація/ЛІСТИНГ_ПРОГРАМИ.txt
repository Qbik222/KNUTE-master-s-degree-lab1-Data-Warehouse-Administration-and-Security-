================================================================================
ЛІСТИНГ ПРОГРАМНОГО ПРОДУКТУ
Операційна оболонка з моделлю Take-Grant
================================================================================


================================================================================
Файл: main.py
================================================================================

   1 | #!/usr/bin/env python3
   2 | """
   3 | Головний файл запуску операційної оболонки Take-Grant
   4 | """
   5 | 
   6 | import os
   7 | import sys
   8 | 
   9 | # Додаємо поточну директорію до шляху
  10 | sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
  11 | 
  12 | from modules.auth import AuthenticationModule
  13 | from modules.objects import ObjectIdentifier
  14 | from modules.access_graph import AccessGraph
  15 | from modules.security_kernel import SecurityKernel
  16 | from modules.operations import OperationsModule
  17 | from modules.admin import AdminModule
  18 | from modules.audit import AuditModule
  19 | from modules.cli import CLI
  20 | 
  21 | 
  22 | def main():
  23 |     """Головна функція"""
  24 |     # Ініціалізація всіх модулів
  25 |     print("Ініціалізація системи...")
  26 |     
  27 |     # Визначаємо шляхи до файлів даних
  28 |     base_dir = os.path.dirname(os.path.abspath(__file__))
  29 |     data_dir = os.path.join(base_dir, "data")
  30 |     logs_dir = os.path.join(base_dir, "logs")
  31 |     
  32 |     # Створюємо директорії якщо не існують
  33 |     os.makedirs(data_dir, exist_ok=True)
  34 |     os.makedirs(logs_dir, exist_ok=True)
  35 |     
  36 |     data_file = os.path.join(data_dir, "system.json")
  37 |     audit_log = os.path.join(logs_dir, "audit.log")
  38 |     audit_json = os.path.join(data_dir, "audit.json")
  39 |     
  40 |     # Ініціалізація модулів
  41 |     auth_module = AuthenticationModule(data_file)
  42 |     object_identifier = ObjectIdentifier()
  43 |     access_graph = AccessGraph()
  44 |     security_kernel = SecurityKernel(access_graph)
  45 |     operations_module = OperationsModule(
  46 |         object_identifier, access_graph, security_kernel
  47 |     )
  48 |     admin_module = AdminModule(
  49 |         auth_module, object_identifier, access_graph, security_kernel
  50 |     )
  51 |     audit_module = AuditModule(audit_log, audit_json)
  52 |     
  53 |     # Завантаження даних (якщо потрібно)
  54 |     # TODO: Додати завантаження графа доступу та об'єктів з файлу
  55 |     
  56 |     # Створення та запуск CLI
  57 |     cli = CLI(
  58 |         auth_module,
  59 |         object_identifier,
  60 |         access_graph,
  61 |         security_kernel,
  62 |         operations_module,
  63 |         admin_module,
  64 |         audit_module
  65 |     )
  66 |     
  67 |     print("Система готова до роботи!\n")
  68 |     cli.run()
  69 |     
  70 |     # Збереження даних перед виходом
  71 |     print("\nЗбереження даних...")
  72 |     auth_module.save_data()
  73 |     audit_module.save_events()
  74 |     # TODO: Додати збереження графа доступу та об'єктів
  75 |     print("Дані збережено.")
  76 | 
  77 | 
  78 | if __name__ == "__main__":
  79 |     try:
  80 |         main()
  81 |     except KeyboardInterrupt:
  82 |         print("\n\nПрограму перервано користувачем.")
  83 |         sys.exit(0)
  84 |     except Exception as e:
  85 |         print(f"\nКритична помилка: {e}")
  86 |         import traceback
  87 |         traceback.print_exc()
  88 |         sys.exit(1)
  89 | 


================================================================================
Файл: modules/auth.py
================================================================================

   1 | """
   2 | Модуль реєстрації та авторизації суб'єктів
   3 | """
   4 | 
   5 | import hashlib
   6 | import json
   7 | import os
   8 | from typing import Dict, Optional
   9 | 
  10 | 
  11 | class AuthenticationModule:
  12 |     """Модуль для реєстрації та авторизації користувачів"""
  13 |     
  14 |     def __init__(self, data_file: str = "data/system.json"):
  15 |         """
  16 |         Ініціалізація модуля автентифікації
  17 |         
  18 |         Args:
  19 |             data_file: Шлях до файлу з даними системи
  20 |         """
  21 |         self.data_file = data_file
  22 |         self.users: Dict[str, Dict] = {}
  23 |         self.current_user: Optional[str] = None
  24 |         self.load_data()
  25 |     
  26 |     def _hash_password(self, password: str) -> str:
  27 |         """Хешування пароля"""
  28 |         return hashlib.sha256(password.encode()).hexdigest()
  29 |     
  30 |     def load_data(self):
  31 |         """Завантаження даних користувачів з файлу"""
  32 |         if os.path.exists(self.data_file):
  33 |             try:
  34 |                 with open(self.data_file, 'r', encoding='utf-8') as f:
  35 |                     data = json.load(f)
  36 |                     self.users = data.get('users', {})
  37 |             except (json.JSONDecodeError, IOError):
  38 |                 self.users = {}
  39 |         else:
  40 |             # Створюємо директорію якщо не існує
  41 |             os.makedirs(os.path.dirname(self.data_file), exist_ok=True)
  42 |             self.users = {}
  43 |     
  44 |     def save_data(self):
  45 |         """Збереження даних користувачів у файл"""
  46 |         os.makedirs(os.path.dirname(self.data_file), exist_ok=True)
  47 |         data = {
  48 |             'users': self.users
  49 |         }
  50 |         with open(self.data_file, 'w', encoding='utf-8') as f:
  51 |             json.dump(data, f, indent=2, ensure_ascii=False)
  52 |     
  53 |     def register(self, username: str, password: str) -> bool:
  54 |         """
  55 |         Реєстрація нового користувача
  56 |         
  57 |         Args:
  58 |             username: Ім'я користувача
  59 |             password: Пароль
  60 |             
  61 |         Returns:
  62 |             True якщо реєстрація успішна, False якщо користувач вже існує
  63 |         """
  64 |         if username in self.users:
  65 |             return False
  66 |         
  67 |         self.users[username] = {
  68 |             'password_hash': self._hash_password(password),
  69 |             'is_admin': False,
  70 |             'created_at': str(os.path.getmtime(self.data_file) if os.path.exists(self.data_file) else 0)
  71 |         }
  72 |         self.save_data()
  73 |         return True
  74 |     
  75 |     def login(self, username: str, password: str) -> bool:
  76 |         """
  77 |         Авторизація користувача
  78 |         
  79 |         Args:
  80 |             username: Ім'я користувача
  81 |             password: Пароль
  82 |             
  83 |         Returns:
  84 |             True якщо авторизація успішна, False інакше
  85 |         """
  86 |         if username not in self.users:
  87 |             return False
  88 |         
  89 |         password_hash = self._hash_password(password)
  90 |         if self.users[username]['password_hash'] == password_hash:
  91 |             self.current_user = username
  92 |             return True
  93 |         return False
  94 |     
  95 |     def logout(self):
  96 |         """Вихід з системи"""
  97 |         self.current_user = None
  98 |     
  99 |     def is_authenticated(self) -> bool:
 100 |         """Перевірка чи користувач авторизований"""
 101 |         return self.current_user is not None
 102 |     
 103 |     def get_current_user(self) -> Optional[str]:
 104 |         """Отримання поточного користувача"""
 105 |         return self.current_user
 106 |     
 107 |     def is_admin(self, username: Optional[str] = None) -> bool:
 108 |         """
 109 |         Перевірка чи користувач є адміністратором
 110 |         
 111 |         Args:
 112 |             username: Ім'я користувача (якщо None, перевіряється поточний)
 113 |         """
 114 |         user = username or self.current_user
 115 |         if user and user in self.users:
 116 |             return self.users[user].get('is_admin', False)
 117 |         return False
 118 |     
 119 |     def set_admin(self, username: str, is_admin: bool = True):
 120 |         """
 121 |         Встановлення прав адміністратора
 122 |         
 123 |         Args:
 124 |             username: Ім'я користувача
 125 |             is_admin: True для надання прав адміністратора
 126 |         """
 127 |         if username in self.users:
 128 |             self.users[username]['is_admin'] = is_admin
 129 |             self.save_data()
 130 |     
 131 |     def list_users(self) -> list:
 132 |         """Отримання списку всіх користувачів"""
 133 |         return list(self.users.keys())
 134 | 


================================================================================
Файл: modules/objects.py
================================================================================

   1 | """
   2 | Модуль однозначної ідентифікації об'єктів
   3 | """
   4 | 
   5 | import uuid
   6 | from typing import Dict, Set, Optional
   7 | from enum import Enum
   8 | 
   9 | 
  10 | class ObjectType(Enum):
  11 |     """Типи об'єктів у системі"""
  12 |     FILE = "file"
  13 |     DIRECTORY = "directory"
  14 |     SUBJECT = "subject"  # Суб'єкт також є об'єктом
  15 | 
  16 | 
  17 | class ObjectIdentifier:
  18 |     """Модуль для ідентифікації об'єктів"""
  19 |     
  20 |     def __init__(self):
  21 |         """Ініціалізація модуля ідентифікації"""
  22 |         self.objects: Dict[str, Dict] = {}  # object_id -> {type, name, owner, ...}
  23 |         self.name_to_id: Dict[str, str] = {}  # name -> object_id (для швидкого пошуку)
  24 |     
  25 |     def generate_id(self) -> str:
  26 |         """Генерація унікального ідентифікатора об'єкта"""
  27 |         return str(uuid.uuid4())
  28 |     
  29 |     def create_object(self, name: str, obj_type: ObjectType, owner: str, 
  30 |                      parent_id: Optional[str] = None) -> str:
  31 |         """
  32 |         Створення нового об'єкта
  33 |         
  34 |         Args:
  35 |             name: Ім'я об'єкта
  36 |             obj_type: Тип об'єкта
  37 |             owner: Власник об'єкта
  38 |             parent_id: ID батьківського об'єкта (для файлів/каталогів)
  39 |             
  40 |         Returns:
  41 |             ID створеного об'єкта
  42 |         """
  43 |         # Перевірка на унікальність імені
  44 |         if name in self.name_to_id:
  45 |             raise ValueError(f"Об'єкт з ім'ям '{name}' вже існує")
  46 |         
  47 |         object_id = self.generate_id()
  48 |         self.objects[object_id] = {
  49 |             'id': object_id,
  50 |             'name': name,
  51 |             'type': obj_type.value,
  52 |             'owner': owner,
  53 |             'parent_id': parent_id,
  54 |             'created_at': str(uuid.uuid1().time)
  55 |         }
  56 |         self.name_to_id[name] = object_id
  57 |         return object_id
  58 |     
  59 |     def get_object(self, identifier: str) -> Optional[Dict]:
  60 |         """
  61 |         Отримання об'єкта за ID або ім'ям
  62 |         
  63 |         Args:
  64 |             identifier: ID або ім'я об'єкта
  65 |             
  66 |         Returns:
  67 |             Словник з даними об'єкта або None
  68 |         """
  69 |         # Спочатку перевіряємо чи це ID
  70 |         if identifier in self.objects:
  71 |             return self.objects[identifier]
  72 |         
  73 |         # Якщо ні, шукаємо за ім'ям
  74 |         if identifier in self.name_to_id:
  75 |             object_id = self.name_to_id[identifier]
  76 |             return self.objects[object_id]
  77 |         
  78 |         return None
  79 |     
  80 |     def get_object_id(self, identifier: str) -> Optional[str]:
  81 |         """
  82 |         Отримання ID об'єкта за ім'ям або ID
  83 |         
  84 |         Args:
  85 |             identifier: Ім'я або ID об'єкта
  86 |             
  87 |         Returns:
  88 |             ID об'єкта або None
  89 |         """
  90 |         if identifier in self.objects:
  91 |             return identifier
  92 |         
  93 |         if identifier in self.name_to_id:
  94 |             return self.name_to_id[identifier]
  95 |         
  96 |         return None
  97 |     
  98 |     def delete_object(self, identifier: str) -> bool:
  99 |         """
 100 |         Видалення об'єкта
 101 |         
 102 |         Args:
 103 |             identifier: ID або ім'я об'єкта
 104 |             
 105 |         Returns:
 106 |             True якщо видалення успішне
 107 |         """
 108 |         object_id = self.get_object_id(identifier)
 109 |         if not object_id:
 110 |             return False
 111 |         
 112 |         obj = self.objects[object_id]
 113 |         name = obj['name']
 114 |         
 115 |         # Видаляємо з обох словників
 116 |         del self.objects[object_id]
 117 |         if name in self.name_to_id:
 118 |             del self.name_to_id[name]
 119 |         
 120 |         return True
 121 |     
 122 |     def list_objects(self, obj_type: Optional[ObjectType] = None, 
 123 |                     owner: Optional[str] = None) -> list:
 124 |         """
 125 |         Отримання списку об'єктів з фільтрацією
 126 |         
 127 |         Args:
 128 |             obj_type: Фільтр за типом (None - всі типи)
 129 |             owner: Фільтр за власником (None - всі власники)
 130 |             
 131 |         Returns:
 132 |             Список об'єктів
 133 |         """
 134 |         result = []
 135 |         for obj in self.objects.values():
 136 |             if obj_type and obj['type'] != obj_type.value:
 137 |                 continue
 138 |             if owner and obj['owner'] != owner:
 139 |                 continue
 140 |             result.append(obj)
 141 |         return result
 142 |     
 143 |     def get_objects_by_owner(self, owner: str) -> list:
 144 |         """Отримання всіх об'єктів власника"""
 145 |         return self.list_objects(owner=owner)
 146 |     
 147 |     def object_exists(self, identifier: str) -> bool:
 148 |         """Перевірка існування об'єкта"""
 149 |         return self.get_object(identifier) is not None
 150 | 


================================================================================
Файл: modules/access_graph.py
================================================================================

   1 | """
   2 | Модуль графа доступу для моделі Take-Grant
   3 | """
   4 | 
   5 | from typing import Dict, Set, Optional, List, Tuple
   6 | from enum import Enum
   7 | 
   8 | 
   9 | class AccessRight(Enum):
  10 |     """Права доступу в моделі Take-Grant"""
  11 |     READ = "r"      # Читання
  12 |     WRITE = "w"     # Запис
  13 |     EXECUTE = "x"   # Виконання
  14 |     TAKE = "t"      # Право брати права
  15 |     GRANT = "g"     # Право надавати права
  16 |     OWN = "o"       # Право власності
  17 | 
  18 | 
  19 | class AccessGraph:
  20 |     """
  21 |     Граф доступу для моделі Take-Grant
  22 |     
  23 |     Граф представлений як словник, де ключ - це пара (subject_id, object_id),
  24 |     а значення - множина прав доступу.
  25 |     """
  26 |     
  27 |     def __init__(self):
  28 |         """Ініціалізація графа доступу"""
  29 |         # Граф: (subject_id, object_id) -> Set[AccessRight]
  30 |         self.graph: Dict[Tuple[str, str], Set[AccessRight]] = {}
  31 |         # Для швидкого пошуку: subject_id -> Set[object_id]
  32 |         self.subject_edges: Dict[str, Set[str]] = {}
  33 |         # Для швидкого пошуку: object_id -> Set[subject_id]
  34 |         self.object_edges: Dict[str, Set[str]] = {}
  35 |     
  36 |     def _normalize_edge(self, subject_id: str, object_id: str) -> Tuple[str, str]:
  37 |         """Нормалізація ребра графа"""
  38 |         return (subject_id, object_id)
  39 |     
  40 |     def add_right(self, subject_id: str, object_id: str, right: AccessRight):
  41 |         """
  42 |         Додавання права доступу
  43 |         
  44 |         Args:
  45 |             subject_id: ID суб'єкта
  46 |             object_id: ID об'єкта
  47 |             right: Право доступу
  48 |         """
  49 |         edge = self._normalize_edge(subject_id, object_id)
  50 |         
  51 |         if edge not in self.graph:
  52 |             self.graph[edge] = set()
  53 |         
  54 |         self.graph[edge].add(right)
  55 |         
  56 |         # Оновлюємо індекси для швидкого пошуку
  57 |         if subject_id not in self.subject_edges:
  58 |             self.subject_edges[subject_id] = set()
  59 |         self.subject_edges[subject_id].add(object_id)
  60 |         
  61 |         if object_id not in self.object_edges:
  62 |             self.object_edges[object_id] = set()
  63 |         self.object_edges[object_id].add(subject_id)
  64 |     
  65 |     def remove_right(self, subject_id: str, object_id: str, right: AccessRight):
  66 |         """
  67 |         Видалення права доступу
  68 |         
  69 |         Args:
  70 |             subject_id: ID суб'єкта
  71 |             object_id: ID об'єкта
  72 |             right: Право доступу
  73 |         """
  74 |         edge = self._normalize_edge(subject_id, object_id)
  75 |         
  76 |         if edge in self.graph:
  77 |             self.graph[edge].discard(right)
  78 |             
  79 |             # Якщо множина прав порожня, видаляємо ребро
  80 |             if not self.graph[edge]:
  81 |                 del self.graph[edge]
  82 |                 self.subject_edges[subject_id].discard(object_id)
  83 |                 self.object_edges[object_id].discard(subject_id)
  84 |     
  85 |     def has_right(self, subject_id: str, object_id: str, right: AccessRight) -> bool:
  86 |         """
  87 |         Перевірка наявності права доступу
  88 |         
  89 |         Args:
  90 |             subject_id: ID суб'єкта
  91 |             object_id: ID об'єкта
  92 |             right: Право доступу
  93 |             
  94 |         Returns:
  95 |             True якщо право існує
  96 |         """
  97 |         edge = self._normalize_edge(subject_id, object_id)
  98 |         return edge in self.graph and right in self.graph[edge]
  99 |     
 100 |     def get_rights(self, subject_id: str, object_id: str) -> Set[AccessRight]:
 101 |         """
 102 |         Отримання всіх прав суб'єкта до об'єкта
 103 |         
 104 |         Args:
 105 |             subject_id: ID суб'єкта
 106 |             object_id: ID об'єкта
 107 |             
 108 |         Returns:
 109 |             Множина прав доступу
 110 |         """
 111 |         edge = self._normalize_edge(subject_id, object_id)
 112 |         return self.graph.get(edge, set())
 113 |     
 114 |     def take(self, subject_id: str, source_object_id: str, target_object_id: str, 
 115 |              rights: Set[AccessRight]) -> bool:
 116 |         """
 117 |         Операція Take: суб'єкт бере права від source_object до target_object
 118 |         
 119 |         Правило: Якщо subject має право 't' до source_object, і source_object
 120 |         має права до target_object, то subject може отримати ці права.
 121 |         
 122 |         Args:
 123 |             subject_id: ID суб'єкта, який виконує операцію
 124 |             source_object_id: ID об'єкта, від якого беруться права
 125 |             target_object_id: ID об'єкта, до якого беруться права
 126 |             rights: Множина прав, які потрібно взяти
 127 |             
 128 |         Returns:
 129 |             True якщо операція успішна
 130 |         """
 131 |         # Перевірка: чи має subject право 't' до source_object
 132 |         if not self.has_right(subject_id, source_object_id, AccessRight.TAKE):
 133 |             return False
 134 |         
 135 |         # Перевірка: чи має source_object права до target_object
 136 |         source_rights = self.get_rights(source_object_id, target_object_id)
 137 |         if not source_rights:
 138 |             return False
 139 |         
 140 |         # Беремо тільки ті права, які є у source_object
 141 |         available_rights = rights.intersection(source_rights)
 142 |         
 143 |         # Додаємо права subject до target_object
 144 |         for right in available_rights:
 145 |             self.add_right(subject_id, target_object_id, right)
 146 |         
 147 |         return len(available_rights) > 0
 148 |     
 149 |     def grant(self, subject_id: str, source_object_id: str, target_subject_id: str,
 150 |               rights: Set[AccessRight]) -> bool:
 151 |         """
 152 |         Операція Grant: суб'єкт надає права від source_object іншому суб'єкту
 153 |         
 154 |         Правило: Якщо subject має право 'g' до source_object, і subject має
 155 |         права до source_object, то subject може надати ці права target_subject.
 156 |         
 157 |         Args:
 158 |             subject_id: ID суб'єкта, який виконує операцію
 159 |             source_object_id: ID об'єкта, права від якого надаються
 160 |             target_subject_id: ID суб'єкта, якому надаються права
 161 |             rights: Множина прав, які потрібно надати
 162 |             
 163 |         Returns:
 164 |             True якщо операція успішна
 165 |         """
 166 |         # Перевірка: чи має subject право 'g' до source_object
 167 |         if not self.has_right(subject_id, source_object_id, AccessRight.GRANT):
 168 |             return False
 169 |         
 170 |         # Перевірка: чи має subject права до source_object
 171 |         subject_rights = self.get_rights(subject_id, source_object_id)
 172 |         if not subject_rights:
 173 |             return False
 174 |         
 175 |         # Надаємо тільки ті права, які є у subject
 176 |         available_rights = rights.intersection(subject_rights)
 177 |         
 178 |         # Додаємо права target_subject до source_object
 179 |         for right in available_rights:
 180 |             self.add_right(target_subject_id, source_object_id, right)
 181 |         
 182 |         return len(available_rights) > 0
 183 |     
 184 |     def create(self, subject_id: str, object_id: str, 
 185 |                rights: Set[AccessRight] = None) -> bool:
 186 |         """
 187 |         Операція Create: суб'єкт створює об'єкт і отримує до нього всі права
 188 |         
 189 |         Args:
 190 |             subject_id: ID суб'єкта, який створює об'єкт
 191 |             object_id: ID створюваного об'єкта
 192 |             rights: Права доступу (за замовчуванням всі)
 193 |             
 194 |         Returns:
 195 |             True якщо операція успішна
 196 |         """
 197 |         if rights is None:
 198 |             # За замовчуванням надаємо всі права
 199 |             rights = {AccessRight.READ, AccessRight.WRITE, AccessRight.EXECUTE,
 200 |                      AccessRight.TAKE, AccessRight.GRANT, AccessRight.OWN}
 201 |         
 202 |         for right in rights:
 203 |             self.add_right(subject_id, object_id, right)
 204 |         
 205 |         return True
 206 |     
 207 |     def remove(self, subject_id: str, object_id: str, rights: Set[AccessRight]):
 208 |         """
 209 |         Операція Remove: видалення прав доступу
 210 |         
 211 |         Args:
 212 |             subject_id: ID суб'єкта
 213 |             object_id: ID об'єкта
 214 |             rights: Множина прав для видалення
 215 |         """
 216 |         for right in rights:
 217 |             self.remove_right(subject_id, object_id, right)
 218 |     
 219 |     def get_all_edges(self) -> List[Tuple[str, str, Set[AccessRight]]]:
 220 |         """
 221 |         Отримання всіх ребер графа
 222 |         
 223 |         Returns:
 224 |             Список кортежів (subject_id, object_id, rights)
 225 |         """
 226 |         result = []
 227 |         for (subject_id, object_id), rights in self.graph.items():
 228 |             if rights:  # Тільки якщо є права
 229 |                 result.append((subject_id, object_id, rights))
 230 |         return result
 231 |     
 232 |     def get_subject_objects(self, subject_id: str) -> Set[str]:
 233 |         """Отримання всіх об'єктів, до яких має доступ суб'єкт"""
 234 |         return self.subject_edges.get(subject_id, set())
 235 |     
 236 |     def get_object_subjects(self, object_id: str) -> Set[str]:
 237 |         """Отримання всіх суб'єктів, які мають доступ до об'єкта"""
 238 |         return self.object_edges.get(object_id, set())
 239 | 


================================================================================
Файл: modules/security_kernel.py
================================================================================

   1 | """
   2 | Модуль ядра безпеки - перевірка доступу з використанням DFS
   3 | """
   4 | 
   5 | from typing import Set, Optional, List
   6 | from .access_graph import AccessGraph, AccessRight
   7 | 
   8 | 
   9 | class SecurityKernel:
  10 |     """
  11 |     Ядро безпеки для перевірки можливості отримання доступу
  12 |     використовуючи алгоритм DFS для пошуку шляхів у графі Take-Grant
  13 |     """
  14 |     
  15 |     def __init__(self, access_graph: AccessGraph):
  16 |         """
  17 |         Ініціалізація ядра безпеки
  18 |         
  19 |         Args:
  20 |             access_graph: Граф доступу
  21 |         """
  22 |         self.access_graph = access_graph
  23 |     
  24 |     def can_access(self, subject_id: str, object_id: str, 
  25 |                   required_right: AccessRight) -> bool:
  26 |         """
  27 |         Перевірка чи може суб'єкт отримати доступ до об'єкта
  28 |         
  29 |         Використовує DFS для пошуку можливого шляху отримання прав
  30 |         через операції take/grant.
  31 |         
  32 |         Args:
  33 |             subject_id: ID суб'єкта
  34 |             object_id: ID об'єкта
  35 |             required_right: Необхідне право доступу
  36 |             
  37 |         Returns:
  38 |             True якщо доступ можливий
  39 |         """
  40 |         # Спочатку перевіряємо чи є пряме право
  41 |         if self.access_graph.has_right(subject_id, object_id, required_right):
  42 |             return True
  43 |         
  44 |         # Якщо немає прямого доступу, шукаємо шлях через take/grant
  45 |         return self._find_access_path(subject_id, object_id, required_right)
  46 |     
  47 |     def _find_access_path(self, subject_id: str, object_id: str,
  48 |                           required_right: AccessRight) -> bool:
  49 |         """
  50 |         Пошук шляху отримання доступу через DFS
  51 |         
  52 |         Алгоритм:
  53 |         1. Шукаємо об'єкти, до яких subject має право 't' (take)
  54 |         2. Для кожного такого об'єкта перевіряємо чи він має доступ до target
  55 |         3. Якщо так, то subject може отримати доступ через take
  56 |         4. Аналогічно для grant - шукаємо суб'єктів, які можуть надати доступ
  57 |         """
  58 |         visited = set()
  59 |         return self._dfs_search(subject_id, object_id, required_right, visited)
  60 |     
  61 |     def _dfs_search(self, current_subject: str, target_object: str,
  62 |                    required_right: AccessRight, visited: Set[str]) -> bool:
  63 |         """
  64 |         Рекурсивний пошук у глибину (DFS)
  65 |         
  66 |         Args:
  67 |             current_subject: Поточний суб'єкт
  68 |             target_object: Цільовий об'єкт
  69 |             required_right: Необхідне право
  70 |             visited: Множина відвіданих вузлів (для уникнення циклів)
  71 |             
  72 |         Returns:
  73 |             True якщо знайдено шлях
  74 |         """
  75 |         # Уникаємо циклів
  76 |         if current_subject in visited:
  77 |             return False
  78 |         visited.add(current_subject)
  79 |         
  80 |         # Перевірка прямого доступу
  81 |         if self.access_graph.has_right(current_subject, target_object, required_right):
  82 |             return True
  83 |         
  84 |         # Шукаємо через операцію TAKE
  85 |         # Знаходимо об'єкти, до яких current_subject має право 't'
  86 |         objects_with_take = self.access_graph.get_subject_objects(current_subject)
  87 |         
  88 |         for intermediate_object in objects_with_take:
  89 |             # Перевіряємо чи має current_subject право 't' до intermediate_object
  90 |             if not self.access_graph.has_right(current_subject, intermediate_object, 
  91 |                                              AccessRight.TAKE):
  92 |                 continue
  93 |             
  94 |             # Перевіряємо чи має intermediate_object доступ до target_object
  95 |             if self.access_graph.has_right(intermediate_object, target_object, 
  96 |                                          required_right):
  97 |                 # Знайдено шлях через take!
  98 |                 return True
  99 |             
 100 |             # Рекурсивно шукаємо далі через intermediate_object
 101 |             # (якщо intermediate_object є суб'єктом)
 102 |             if self._dfs_search(intermediate_object, target_object, 
 103 |                               required_right, visited.copy()):
 104 |                 return True
 105 |         
 106 |         # Шукаємо через операцію GRANT
 107 |         # Знаходимо суб'єктів, які мають право 'g' до об'єктів з доступом до target
 108 |         all_objects = set()
 109 |         for (s, o), rights in self.access_graph.graph.items():
 110 |             all_objects.add(o)
 111 |         
 112 |         for intermediate_object in all_objects:
 113 |             # Знаходимо суб'єктів, які мають право 'g' до intermediate_object
 114 |             subjects_with_grant = self.access_graph.get_object_subjects(intermediate_object)
 115 |             
 116 |             for grant_subject in subjects_with_grant:
 117 |                 if not self.access_graph.has_right(grant_subject, intermediate_object,
 118 |                                                  AccessRight.GRANT):
 119 |                     continue
 120 |                 
 121 |                 # Перевіряємо чи має intermediate_object доступ до target_object
 122 |                 if self.access_graph.has_right(intermediate_object, target_object,
 123 |                                              required_right):
 124 |                     # Можливий шлях через grant (якщо grant_subject надасть доступ)
 125 |                     # Для спрощення вважаємо що це можливо
 126 |                     return True
 127 |         
 128 |         return False
 129 |     
 130 |     def get_accessible_objects(self, subject_id: str, 
 131 |                                required_right: AccessRight) -> List[str]:
 132 |         """
 133 |         Отримання списку об'єктів, до яких суб'єкт може отримати доступ
 134 |         
 135 |         Args:
 136 |             subject_id: ID суб'єкта
 137 |             required_right: Необхідне право
 138 |             
 139 |         Returns:
 140 |             Список ID об'єктів
 141 |         """
 142 |         accessible = []
 143 |         
 144 |         # Отримуємо всі об'єкти з графа
 145 |         all_objects = set()
 146 |         for (s, o), rights in self.access_graph.graph.items():
 147 |             all_objects.add(o)
 148 |             all_objects.add(s)  # Суб'єкти теж можуть бути об'єктами
 149 |         
 150 |         for object_id in all_objects:
 151 |             if self.can_access(subject_id, object_id, required_right):
 152 |                 accessible.append(object_id)
 153 |         
 154 |         return accessible
 155 |     
 156 |     def check_right(self, subject_id: str, object_id: str, 
 157 |                    right: AccessRight) -> bool:
 158 |         """
 159 |         Перевірка наявності права (з урахуванням можливості отримання)
 160 |         
 161 |         Args:
 162 |             subject_id: ID суб'єкта
 163 |             object_id: ID об'єкта
 164 |             right: Право доступу
 165 |             
 166 |         Returns:
 167 |             True якщо право існує або може бути отримане
 168 |         """
 169 |         return self.can_access(subject_id, object_id, right)
 170 | 


================================================================================
Файл: modules/operations.py
================================================================================

   1 | """
   2 | Модуль операцій над об'єктами (симуляція файлової системи)
   3 | """
   4 | 
   5 | from typing import Dict, Optional
   6 | from .objects import ObjectIdentifier, ObjectType
   7 | from .access_graph import AccessGraph, AccessRight
   8 | from .security_kernel import SecurityKernel
   9 | 
  10 | 
  11 | class OperationsModule:
  12 |     """
  13 |     Модуль для виконання операцій над об'єктами
  14 |     Симулює файлову систему з контролем доступу
  15 |     """
  16 |     
  17 |     def __init__(self, object_identifier: ObjectIdentifier,
  18 |                  access_graph: AccessGraph,
  19 |                  security_kernel: SecurityKernel):
  20 |         """
  21 |         Ініціалізація модуля операцій
  22 |         
  23 |         Args:
  24 |             object_identifier: Модуль ідентифікації об'єктів
  25 |             access_graph: Граф доступу
  26 |             security_kernel: Ядро безпеки
  27 |         """
  28 |         self.object_identifier = object_identifier
  29 |         self.access_graph = access_graph
  30 |         self.security_kernel = security_kernel
  31 |         # Симуляція вмісту файлів: object_id -> content
  32 |         self.file_contents: Dict[str, str] = {}
  33 |     
  34 |     def read_file(self, subject_id: str, object_id: str) -> Optional[str]:
  35 |         """
  36 |         Читання файлу
  37 |         
  38 |         Args:
  39 |             subject_id: ID суб'єкта
  40 |             object_id: ID об'єкта (файлу)
  41 |             
  42 |         Returns:
  43 |             Вміст файлу або None якщо доступ заборонено
  44 |         """
  45 |         # Перевірка доступу
  46 |         if not self.security_kernel.can_access(subject_id, object_id, 
  47 |                                                AccessRight.READ):
  48 |             return None
  49 |         
  50 |         obj = self.object_identifier.get_object(object_id)
  51 |         if not obj or obj['type'] != ObjectType.FILE.value:
  52 |             return None
  53 |         
  54 |         return self.file_contents.get(object_id, "")
  55 |     
  56 |     def write_file(self, subject_id: str, object_id: str, content: str) -> bool:
  57 |         """
  58 |         Запис у файл
  59 |         
  60 |         Args:
  61 |             subject_id: ID суб'єкта
  62 |             object_id: ID об'єкта (файлу)
  63 |             content: Вміст для запису
  64 |             
  65 |         Returns:
  66 |             True якщо запис успішний
  67 |         """
  68 |         # Перевірка доступу
  69 |         if not self.security_kernel.can_access(subject_id, object_id,
  70 |                                               AccessRight.WRITE):
  71 |             return False
  72 |         
  73 |         obj = self.object_identifier.get_object(object_id)
  74 |         if not obj or obj['type'] != ObjectType.FILE.value:
  75 |             return False
  76 |         
  77 |         self.file_contents[object_id] = content
  78 |         return True
  79 |     
  80 |     def execute_file(self, subject_id: str, object_id: str) -> bool:
  81 |         """
  82 |         Виконання файлу
  83 |         
  84 |         Args:
  85 |             subject_id: ID суб'єкта
  86 |             object_id: ID об'єкта (файлу)
  87 |             
  88 |         Returns:
  89 |             True якщо виконання дозволено
  90 |         """
  91 |         # Перевірка доступу
  92 |         if not self.security_kernel.can_access(subject_id, object_id,
  93 |                                               AccessRight.EXECUTE):
  94 |             return False
  95 |         
  96 |         obj = self.object_identifier.get_object(object_id)
  97 |         if not obj or obj['type'] != ObjectType.FILE.value:
  98 |             return False
  99 |         
 100 |         # Симуляція виконання (в реальній системі тут була б виконана програма)
 101 |         return True
 102 |     
 103 |     def create_file(self, subject_id: str, name: str, 
 104 |                    parent_id: Optional[str] = None) -> Optional[str]:
 105 |         """
 106 |         Створення файлу
 107 |         
 108 |         Args:
 109 |             subject_id: ID суб'єкта
 110 |             name: Ім'я файлу
 111 |             parent_id: ID батьківського каталогу
 112 |             
 113 |         Returns:
 114 |             ID створеного файлу або None
 115 |         """
 116 |         try:
 117 |             object_id = self.object_identifier.create_object(
 118 |                 name, ObjectType.FILE, subject_id, parent_id
 119 |             )
 120 |             
 121 |             # При створенні власник отримує всі права
 122 |             self.access_graph.create(subject_id, object_id)
 123 |             
 124 |             # Ініціалізуємо порожній вміст
 125 |             self.file_contents[object_id] = ""
 126 |             
 127 |             return object_id
 128 |         except ValueError:
 129 |             return None
 130 |     
 131 |     def create_directory(self, subject_id: str, name: str,
 132 |                         parent_id: Optional[str] = None) -> Optional[str]:
 133 |         """
 134 |         Створення каталогу
 135 |         
 136 |         Args:
 137 |             subject_id: ID суб'єкта
 138 |             name: Ім'я каталогу
 139 |             parent_id: ID батьківського каталогу
 140 |             
 141 |         Returns:
 142 |             ID створеного каталогу або None
 143 |         """
 144 |         try:
 145 |             object_id = self.object_identifier.create_object(
 146 |                 name, ObjectType.DIRECTORY, subject_id, parent_id
 147 |             )
 148 |             
 149 |             # При створенні власник отримує всі права
 150 |             self.access_graph.create(subject_id, object_id)
 151 |             
 152 |             return object_id
 153 |         except ValueError:
 154 |             return None
 155 |     
 156 |     def delete_object(self, subject_id: str, object_id: str) -> bool:
 157 |         """
 158 |         Видалення об'єкта
 159 |         
 160 |         Args:
 161 |             subject_id: ID суб'єкта
 162 |             object_id: ID об'єкта
 163 |             
 164 |         Returns:
 165 |             True якщо видалення успішне
 166 |         """
 167 |         obj = self.object_identifier.get_object(object_id)
 168 |         if not obj:
 169 |             return False
 170 |         
 171 |         # Перевірка: тільки власник може видалити об'єкт
 172 |         if obj['owner'] != subject_id:
 173 |             # Або перевіряємо чи має право OWN
 174 |             if not self.security_kernel.can_access(subject_id, object_id,
 175 |                                                   AccessRight.OWN):
 176 |                 return False
 177 |         
 178 |         # Видаляємо з файлової системи
 179 |         if object_id in self.file_contents:
 180 |             del self.file_contents[object_id]
 181 |         
 182 |         # Видаляємо всі права доступу до цього об'єкта
 183 |         edges_to_remove = []
 184 |         for (s, o), rights in self.access_graph.graph.items():
 185 |             if o == object_id:
 186 |                 edges_to_remove.append((s, o))
 187 |         
 188 |         for s, o in edges_to_remove:
 189 |             del self.access_graph.graph[(s, o)]
 190 |         
 191 |         # Видаляємо з ідентифікатора
 192 |         return self.object_identifier.delete_object(object_id)
 193 |     
 194 |     def list_directory(self, subject_id: str, directory_id: str) -> list:
 195 |         """
 196 |         Отримання списку об'єктів у каталозі
 197 |         
 198 |         Args:
 199 |             subject_id: ID суб'єкта
 200 |             directory_id: ID каталогу
 201 |             
 202 |         Returns:
 203 |             Список об'єктів у каталозі
 204 |         """
 205 |         # Перевірка доступу до каталогу
 206 |         if not self.security_kernel.can_access(subject_id, directory_id,
 207 |                                               AccessRight.READ):
 208 |             return []
 209 |         
 210 |         obj = self.object_identifier.get_object(directory_id)
 211 |         if not obj or obj['type'] != ObjectType.DIRECTORY.value:
 212 |             return []
 213 |         
 214 |         # Знаходимо всі об'єкти з цим батьківським каталогом
 215 |         all_objects = self.object_identifier.list_objects()
 216 |         result = []
 217 |         for obj in all_objects:
 218 |             if obj.get('parent_id') == directory_id:
 219 |                 result.append(obj)
 220 |         
 221 |         return result
 222 |     
 223 |     def get_file_content(self, object_id: str) -> str:
 224 |         """Отримання вмісту файлу (без перевірки доступу)"""
 225 |         return self.file_contents.get(object_id, "")
 226 | 


================================================================================
Файл: modules/admin.py
================================================================================

   1 | """
   2 | Модуль адміністратора для управління системою
   3 | """
   4 | 
   5 | from typing import List, Optional
   6 | from .auth import AuthenticationModule
   7 | from .objects import ObjectIdentifier
   8 | from .access_graph import AccessGraph, AccessRight
   9 | from .security_kernel import SecurityKernel
  10 | 
  11 | 
  12 | class AdminModule:
  13 |     """
  14 |     Модуль адміністратора для управління суб'єктами, об'єктами та правами доступу
  15 |     """
  16 |     
  17 |     def __init__(self, auth_module: AuthenticationModule,
  18 |                  object_identifier: ObjectIdentifier,
  19 |                  access_graph: AccessGraph,
  20 |                  security_kernel: SecurityKernel):
  21 |         """
  22 |         Ініціалізація модуля адміністратора
  23 |         
  24 |         Args:
  25 |             auth_module: Модуль автентифікації
  26 |             object_identifier: Модуль ідентифікації об'єктів
  27 |             access_graph: Граф доступу
  28 |             security_kernel: Ядро безпеки
  29 |         """
  30 |         self.auth_module = auth_module
  31 |         self.object_identifier = object_identifier
  32 |         self.access_graph = access_graph
  33 |         self.security_kernel = security_kernel
  34 |     
  35 |     def is_admin(self, username: str) -> bool:
  36 |         """Перевірка чи користувач є адміністратором"""
  37 |         return self.auth_module.is_admin(username)
  38 |     
  39 |     def set_user_admin(self, admin_username: str, target_username: str, 
  40 |                       is_admin: bool = True) -> bool:
  41 |         """
  42 |         Встановлення прав адміністратора для користувача
  43 |         
  44 |         Args:
  45 |             admin_username: Ім'я адміністратора
  46 |             target_username: Ім'я користувача
  47 |             is_admin: True для надання прав адміністратора
  48 |             
  49 |         Returns:
  50 |             True якщо операція успішна
  51 |         """
  52 |         if not self.is_admin(admin_username):
  53 |             return False
  54 |         
  55 |         self.auth_module.set_admin(target_username, is_admin)
  56 |         return True
  57 |     
  58 |     def list_all_users(self, admin_username: str) -> List[str]:
  59 |         """
  60 |         Отримання списку всіх користувачів
  61 |         
  62 |         Args:
  63 |             admin_username: Ім'я адміністратора
  64 |             
  65 |         Returns:
  66 |             Список імен користувачів
  67 |         """
  68 |         if not self.is_admin(admin_username):
  69 |             return []
  70 |         
  71 |         return self.auth_module.list_users()
  72 |     
  73 |     def list_all_objects(self, admin_username: str) -> List[dict]:
  74 |         """
  75 |         Отримання списку всіх об'єктів
  76 |         
  77 |         Args:
  78 |             admin_username: Ім'я адміністратора
  79 |             
  80 |         Returns:
  81 |             Список об'єктів
  82 |         """
  83 |         if not self.is_admin(admin_username):
  84 |             return []
  85 |         
  86 |         return self.object_identifier.list_objects()
  87 |     
  88 |     def grant_rights(self, admin_username: str, subject_id: str, 
  89 |                     object_id: str, rights: set) -> bool:
  90 |         """
  91 |         Надання прав доступу (адміністративна операція)
  92 |         
  93 |         Args:
  94 |             admin_username: Ім'я адміністратора
  95 |             subject_id: ID суб'єкта
  96 |             object_id: ID об'єкта
  97 |             rights: Множина прав доступу
  98 |             
  99 |         Returns:
 100 |             True якщо операція успішна
 101 |         """
 102 |         if not self.is_admin(admin_username):
 103 |             return False
 104 |         
 105 |         for right in rights:
 106 |             self.access_graph.add_right(subject_id, object_id, right)
 107 |         
 108 |         return True
 109 |     
 110 |     def revoke_rights(self, admin_username: str, subject_id: str,
 111 |                      object_id: str, rights: set) -> bool:
 112 |         """
 113 |         Відкликання прав доступу (адміністративна операція)
 114 |         
 115 |         Args:
 116 |             admin_username: Ім'я адміністратора
 117 |             subject_id: ID суб'єкта
 118 |             object_id: ID об'єкта
 119 |             rights: Множина прав для відкликання
 120 |             
 121 |         Returns:
 122 |             True якщо операція успішна
 123 |         """
 124 |         if not self.is_admin(admin_username):
 125 |             return False
 126 |         
 127 |         for right in rights:
 128 |             self.access_graph.remove_right(subject_id, object_id, right)
 129 |         
 130 |         return True
 131 |     
 132 |     def get_access_matrix(self, admin_username: str) -> List[dict]:
 133 |         """
 134 |         Отримання матриці доступу
 135 |         
 136 |         Args:
 137 |             admin_username: Ім'я адміністратора
 138 |             
 139 |         Returns:
 140 |             Список записів матриці доступу
 141 |         """
 142 |         if not self.is_admin(admin_username):
 143 |             return []
 144 |         
 145 |         matrix = []
 146 |         for (subject_id, object_id), rights in self.access_graph.graph.items():
 147 |             matrix.append({
 148 |                 'subject': subject_id,
 149 |                 'object': object_id,
 150 |                 'rights': [r.value for r in rights]
 151 |             })
 152 |         
 153 |         return matrix
 154 |     
 155 |     def delete_user(self, admin_username: str, target_username: str) -> bool:
 156 |         """
 157 |         Видалення користувача (тільки якщо він не має об'єктів)
 158 |         
 159 |         Args:
 160 |             admin_username: Ім'я адміністратора
 161 |             target_username: Ім'я користувача для видалення
 162 |             
 163 |         Returns:
 164 |             True якщо видалення успішне
 165 |         """
 166 |         if not self.is_admin(admin_username):
 167 |             return False
 168 |         
 169 |         if target_username == admin_username:
 170 |             return False  # Не можна видалити себе
 171 |         
 172 |         # Перевірка чи користувач має об'єкти
 173 |         user_objects = self.object_identifier.get_objects_by_owner(target_username)
 174 |         if user_objects:
 175 |             return False  # Не можна видалити користувача з об'єктами
 176 |         
 177 |         # Видалення користувача (в реальній системі тут була б логіка видалення)
 178 |         # Для спрощення просто повертаємо True
 179 |         return True
 180 | 


================================================================================
Файл: modules/audit.py
================================================================================

   1 | """
   2 | Модуль аудиту подій - журнал подій системи
   3 | """
   4 | 
   5 | import os
   6 | import json
   7 | from datetime import datetime
   8 | from typing import List, Optional
   9 | from enum import Enum
  10 | 
  11 | 
  12 | class EventType(Enum):
  13 |     """Типи подій для аудиту"""
  14 |     LOGIN = "login"
  15 |     LOGOUT = "logout"
  16 |     REGISTER = "register"
  17 |     CREATE_OBJECT = "create_object"
  18 |     DELETE_OBJECT = "delete_object"
  19 |     READ_FILE = "read_file"
  20 |     WRITE_FILE = "write_file"
  21 |     EXECUTE_FILE = "execute_file"
  22 |     TAKE_OPERATION = "take"
  23 |     GRANT_OPERATION = "grant"
  24 |     ACCESS_GRANTED = "access_granted"
  25 |     ACCESS_DENIED = "access_denied"
  26 |     ADMIN_ACTION = "admin_action"
  27 | 
  28 | 
  29 | class AuditModule:
  30 |     """
  31 |     Модуль аудиту для протоколювання подій системи
  32 |     """
  33 |     
  34 |     def __init__(self, log_file: str = "logs/audit.log",
  35 |                  json_file: str = "data/audit.json"):
  36 |         """
  37 |         Ініціалізація модуля аудиту
  38 |         
  39 |         Args:
  40 |             log_file: Шлях до текстового лог-файлу
  41 |             json_file: Шлях до JSON файлу з подіями
  42 |         """
  43 |         self.log_file = log_file
  44 |         self.json_file = json_file
  45 |         self.events: List[dict] = []
  46 |         self.load_events()
  47 |     
  48 |     def load_events(self):
  49 |         """Завантаження подій з JSON файлу"""
  50 |         if os.path.exists(self.json_file):
  51 |             try:
  52 |                 with open(self.json_file, 'r', encoding='utf-8') as f:
  53 |                     data = json.load(f)
  54 |                     self.events = data.get('events', [])
  55 |             except (json.JSONDecodeError, IOError):
  56 |                 self.events = []
  57 |         else:
  58 |             os.makedirs(os.path.dirname(self.json_file), exist_ok=True)
  59 |             self.events = []
  60 |     
  61 |     def save_events(self):
  62 |         """Збереження подій у JSON файл"""
  63 |         os.makedirs(os.path.dirname(self.json_file), exist_ok=True)
  64 |         data = {'events': self.events}
  65 |         with open(self.json_file, 'w', encoding='utf-8') as f:
  66 |             json.dump(data, f, indent=2, ensure_ascii=False)
  67 |     
  68 |     def log_event(self, event_type: EventType, subject: str, 
  69 |                   details: dict = None, success: bool = True):
  70 |         """
  71 |         Протоколювання події
  72 |         
  73 |         Args:
  74 |             event_type: Тип події
  75 |             subject: Суб'єкт, який виконав дію
  76 |             details: Додаткові деталі події
  77 |             success: Чи була операція успішною
  78 |         """
  79 |         event = {
  80 |             'timestamp': datetime.now().isoformat(),
  81 |             'type': event_type.value,
  82 |             'subject': subject,
  83 |             'success': success,
  84 |             'details': details or {}
  85 |         }
  86 |         
  87 |         self.events.append(event)
  88 |         
  89 |         # Зберігаємо у JSON
  90 |         self.save_events()
  91 |         
  92 |         # Записуємо у текстовий лог
  93 |         self._write_log(event)
  94 |     
  95 |     def _write_log(self, event: dict):
  96 |         """Запис події у текстовий лог-файл"""
  97 |         os.makedirs(os.path.dirname(self.log_file), exist_ok=True)
  98 |         
  99 |         status = "SUCCESS" if event['success'] else "FAILED"
 100 |         details_str = ""
 101 |         if event['details']:
 102 |             details_str = " | " + ", ".join([f"{k}={v}" for k, v in event['details'].items()])
 103 |         
 104 |         log_line = f"[{event['timestamp']}] {status} | {event['type']} | " \
 105 |                   f"subject={event['subject']}{details_str}\n"
 106 |         
 107 |         with open(self.log_file, 'a', encoding='utf-8') as f:
 108 |             f.write(log_line)
 109 |     
 110 |     def get_events(self, event_type: Optional[EventType] = None,
 111 |                    subject: Optional[str] = None,
 112 |                    success_only: bool = False,
 113 |                    failed_only: bool = False) -> List[dict]:
 114 |         """
 115 |         Отримання подій з фільтрацією
 116 |         
 117 |         Args:
 118 |             event_type: Фільтр за типом події
 119 |             subject: Фільтр за суб'єктом
 120 |             success_only: Тільки успішні події
 121 |             failed_only: Тільки неуспішні події
 122 |             
 123 |         Returns:
 124 |             Список подій
 125 |         """
 126 |         result = self.events.copy()
 127 |         
 128 |         if event_type:
 129 |             result = [e for e in result if e['type'] == event_type.value]
 130 |         
 131 |         if subject:
 132 |             result = [e for e in result if e['subject'] == subject]
 133 |         
 134 |         if success_only:
 135 |             result = [e for e in result if e['success']]
 136 |         
 137 |         if failed_only:
 138 |             result = [e for e in result if not e['success']]
 139 |         
 140 |         return result
 141 |     
 142 |     def get_failed_accesses(self) -> List[dict]:
 143 |         """Отримання всіх неуспішних спроб доступу"""
 144 |         return self.get_events(event_type=EventType.ACCESS_DENIED)
 145 |     
 146 |     def get_successful_operations(self) -> List[dict]:
 147 |         """Отримання всіх успішних операцій"""
 148 |         return [e for e in self.events if e['success']]
 149 |     
 150 |     def get_all_events(self) -> List[dict]:
 151 |         """Отримання всіх подій"""
 152 |         return self.events.copy()
 153 |     
 154 |     def clear_events(self):
 155 |         """Очищення журналу подій"""
 156 |         self.events = []
 157 |         self.save_events()
 158 |         
 159 |         # Очищаємо текстовий лог
 160 |         if os.path.exists(self.log_file):
 161 |             with open(self.log_file, 'w', encoding='utf-8') as f:
 162 |                 f.write("")
 163 | 


================================================================================
Файл: modules/cli.py
================================================================================

   1 | """
   2 | Консольний інтерфейс (CLI) для операційної оболонки Take-Grant
   3 | """
   4 | 
   5 | from typing import Optional
   6 | from .auth import AuthenticationModule
   7 | from .objects import ObjectIdentifier, ObjectType
   8 | from .access_graph import AccessGraph, AccessRight
   9 | from .security_kernel import SecurityKernel
  10 | from .operations import OperationsModule
  11 | from .admin import AdminModule
  12 | from .audit import AuditModule, EventType
  13 | 
  14 | 
  15 | class CLI:
  16 |     """Консольний інтерфейс користувача"""
  17 |     
  18 |     def __init__(self, auth_module: AuthenticationModule,
  19 |                  object_identifier: ObjectIdentifier,
  20 |                  access_graph: AccessGraph,
  21 |                  security_kernel: SecurityKernel,
  22 |                  operations_module: OperationsModule,
  23 |                  admin_module: AdminModule,
  24 |                  audit_module: AuditModule):
  25 |         """
  26 |         Ініціалізація CLI
  27 |         
  28 |         Args:
  29 |             auth_module: Модуль автентифікації
  30 |             object_identifier: Модуль ідентифікації об'єктів
  31 |             access_graph: Граф доступу
  32 |             security_kernel: Ядро безпеки
  33 |             operations_module: Модуль операцій
  34 |             admin_module: Модуль адміністратора
  35 |             audit_module: Модуль аудиту
  36 |         """
  37 |         self.auth = auth_module
  38 |         self.objects = object_identifier
  39 |         self.graph = access_graph
  40 |         self.security = security_kernel
  41 |         self.ops = operations_module
  42 |         self.admin = admin_module
  43 |         self.audit = audit_module
  44 |         self.current_user_id: Optional[str] = None
  45 |     
  46 |     def print_help(self):
  47 |         """Виведення довідки"""
  48 |         print("\n=== Довідка по командам ===")
  49 |         print("Автентифікація:")
  50 |         print("  register <username> <password>  - Реєстрація нового користувача")
  51 |         print("  login <username> <password>      - Авторизація")
  52 |         print("  logout                           - Вихід з системи")
  53 |         print("\nРобота з об'єктами:")
  54 |         print("  create_file <name>               - Створення файлу")
  55 |         print("  create_dir <name>                - Створення каталогу")
  56 |         print("  read <object_id>                 - Читання файлу")
  57 |         print("  write <object_id> <content>      - Запис у файл")
  58 |         print("  delete <object_id>               - Видалення об'єкта")
  59 |         print("  list                             - Список об'єктів")
  60 |         print("\nОперації Take-Grant:")
  61 |         print("  take <source> <target> <rights>  - Операція take")
  62 |         print("  grant <source> <target> <rights>   - Операція grant")
  63 |         print("  check <object_id> <right>         - Перевірка доступу")
  64 |         print("\nАдміністративні команди:")
  65 |         print("  admin list_users                  - Список користувачів")
  66 |         print("  admin list_objects                - Список всіх об'єктів")
  67 |         print("  admin matrix                     - Матриця доступу")
  68 |         print("  admin grant <s> <o> <rights>     - Надання прав")
  69 |         print("\nАудит:")
  70 |         print("  audit all                        - Всі події")
  71 |         print("  audit failed                     - Неуспішні доступи")
  72 |         print("  audit success                    - Успішні операції")
  73 |         print("\nІнші:")
  74 |         print("  help                             - Ця довідка")
  75 |         print("  exit                             - Вихід з програми")
  76 |         print("================================\n")
  77 |     
  78 |     def run(self):
  79 |         """Головний цикл CLI"""
  80 |         print("=== Операційна оболонка Take-Grant ===")
  81 |         print("Введіть 'help' для довідки або 'register' для реєстрації")
  82 |         
  83 |         while True:
  84 |             try:
  85 |                 if self.current_user_id:
  86 |                     prompt = f"[{self.current_user_id}]> "
  87 |                 else:
  88 |                     prompt = "[не авторизовано]> "
  89 |                 
  90 |                 command = input(prompt).strip()
  91 |                 
  92 |                 if not command:
  93 |                     continue
  94 |                 
  95 |                 parts = command.split()
  96 |                 cmd = parts[0].lower()
  97 |                 args = parts[1:]
  98 |                 
  99 |                 if cmd == "exit":
 100 |                     if self.current_user_id:
 101 |                         self.audit.log_event(EventType.LOGOUT, self.current_user_id)
 102 |                     print("До побачення!")
 103 |                     break
 104 |                 
 105 |                 elif cmd == "help":
 106 |                     self.print_help()
 107 |                 
 108 |                 elif cmd == "register":
 109 |                     self.handle_register(args)
 110 |                 
 111 |                 elif cmd == "login":
 112 |                     self.handle_login(args)
 113 |                 
 114 |                 elif cmd == "logout":
 115 |                     self.handle_logout()
 116 |                 
 117 |                 elif cmd == "create_file":
 118 |                     self.handle_create_file(args)
 119 |                 
 120 |                 elif cmd == "create_dir":
 121 |                     self.handle_create_directory(args)
 122 |                 
 123 |                 elif cmd == "read":
 124 |                     self.handle_read(args)
 125 |                 
 126 |                 elif cmd == "write":
 127 |                     self.handle_write(args)
 128 |                 
 129 |                 elif cmd == "delete":
 130 |                     self.handle_delete(args)
 131 |                 
 132 |                 elif cmd == "list":
 133 |                     self.handle_list()
 134 |                 
 135 |                 elif cmd == "take":
 136 |                     self.handle_take(args)
 137 |                 
 138 |                 elif cmd == "grant":
 139 |                     self.handle_grant(args)
 140 |                 
 141 |                 elif cmd == "check":
 142 |                     self.handle_check(args)
 143 |                 
 144 |                 elif cmd == "admin":
 145 |                     self.handle_admin(args)
 146 |                 
 147 |                 elif cmd == "audit":
 148 |                     self.handle_audit(args)
 149 |                 
 150 |                 else:
 151 |                     print(f"Невідома команда: {cmd}. Введіть 'help' для довідки.")
 152 |             
 153 |             except KeyboardInterrupt:
 154 |                 print("\n\nВихід з програми...")
 155 |                 break
 156 |             except Exception as e:
 157 |                 print(f"Помилка: {e}")
 158 |     
 159 |     def require_auth(self) -> bool:
 160 |         """Перевірка чи користувач авторизований"""
 161 |         if not self.current_user_id:
 162 |             print("Помилка: спочатку увійдіть у систему (команда 'login')")
 163 |             return False
 164 |         return True
 165 |     
 166 |     def handle_register(self, args):
 167 |         """Обробка реєстрації"""
 168 |         if len(args) < 2:
 169 |             print("Використання: register <username> <password>")
 170 |             return
 171 |         
 172 |         username, password = args[0], args[1]
 173 |         if self.auth.register(username, password):
 174 |             print(f"Користувач '{username}' успішно зареєстровано")
 175 |             self.audit.log_event(EventType.REGISTER, username)
 176 |         else:
 177 |             print(f"Помилка: користувач '{username}' вже існує")
 178 |             self.audit.log_event(EventType.REGISTER, username, success=False)
 179 |     
 180 |     def handle_login(self, args):
 181 |         """Обробка авторизації"""
 182 |         if len(args) < 2:
 183 |             print("Використання: login <username> <password>")
 184 |             return
 185 |         
 186 |         username, password = args[0], args[1]
 187 |         if self.auth.login(username, password):
 188 |             self.current_user_id = username
 189 |             print(f"Вітаємо, {username}!")
 190 |             self.audit.log_event(EventType.LOGIN, username)
 191 |         else:
 192 |             print("Помилка: невірне ім'я користувача або пароль")
 193 |             self.audit.log_event(EventType.LOGIN, username, success=False)
 194 |     
 195 |     def handle_logout(self):
 196 |         """Обробка виходу"""
 197 |         if self.current_user_id:
 198 |             self.audit.log_event(EventType.LOGOUT, self.current_user_id)
 199 |             self.current_user_id = None
 200 |             print("Ви вийшли з системи")
 201 |         else:
 202 |             print("Ви не авторизовані")
 203 |     
 204 |     def handle_create_file(self, args):
 205 |         """Обробка створення файлу"""
 206 |         if not self.require_auth():
 207 |             return
 208 |         if len(args) < 1:
 209 |             print("Використання: create_file <name>")
 210 |             return
 211 |         
 212 |         name = args[0]
 213 |         obj_id = self.ops.create_file(self.current_user_id, name)
 214 |         if obj_id:
 215 |             print(f"Файл '{name}' створено (ID: {obj_id})")
 216 |             self.audit.log_event(EventType.CREATE_OBJECT, self.current_user_id,
 217 |                                {'object_id': obj_id, 'name': name, 'type': 'file'})
 218 |         else:
 219 |             print(f"Помилка: не вдалося створити файл '{name}'")
 220 |     
 221 |     def handle_create_directory(self, args):
 222 |         """Обробка створення каталогу"""
 223 |         if not self.require_auth():
 224 |             return
 225 |         if len(args) < 1:
 226 |             print("Використання: create_dir <name>")
 227 |             return
 228 |         
 229 |         name = args[0]
 230 |         obj_id = self.ops.create_directory(self.current_user_id, name)
 231 |         if obj_id:
 232 |             print(f"Каталог '{name}' створено (ID: {obj_id})")
 233 |             self.audit.log_event(EventType.CREATE_OBJECT, self.current_user_id,
 234 |                                {'object_id': obj_id, 'name': name, 'type': 'directory'})
 235 |         else:
 236 |             print(f"Помилка: не вдалося створити каталог '{name}'")
 237 |     
 238 |     def handle_read(self, args):
 239 |         """Обробка читання файлу"""
 240 |         if not self.require_auth():
 241 |             return
 242 |         if len(args) < 1:
 243 |             print("Використання: read <object_id>")
 244 |             return
 245 |         
 246 |         obj_id = args[0]
 247 |         content = self.ops.read_file(self.current_user_id, obj_id)
 248 |         if content is not None:
 249 |             print(f"Вміст файлу:\n{content}")
 250 |             self.audit.log_event(EventType.READ_FILE, self.current_user_id,
 251 |                                {'object_id': obj_id}, success=True)
 252 |         else:
 253 |             print("Помилка: доступ заборонено або файл не існує")
 254 |             self.audit.log_event(EventType.ACCESS_DENIED, self.current_user_id,
 255 |                                {'object_id': obj_id, 'operation': 'read'}, success=False)
 256 |     
 257 |     def handle_write(self, args):
 258 |         """Обробка запису у файл"""
 259 |         if not self.require_auth():
 260 |             return
 261 |         if len(args) < 2:
 262 |             print("Використання: write <object_id> <content>")
 263 |             return
 264 |         
 265 |         obj_id = args[0]
 266 |         content = " ".join(args[1:])
 267 |         if self.ops.write_file(self.current_user_id, obj_id, content):
 268 |             print("Файл успішно записано")
 269 |             self.audit.log_event(EventType.WRITE_FILE, self.current_user_id,
 270 |                                {'object_id': obj_id}, success=True)
 271 |         else:
 272 |             print("Помилка: доступ заборонено або файл не існує")
 273 |             self.audit.log_event(EventType.ACCESS_DENIED, self.current_user_id,
 274 |                                {'object_id': obj_id, 'operation': 'write'}, success=False)
 275 |     
 276 |     def handle_delete(self, args):
 277 |         """Обробка видалення об'єкта"""
 278 |         if not self.require_auth():
 279 |             return
 280 |         if len(args) < 1:
 281 |             print("Використання: delete <object_id>")
 282 |             return
 283 |         
 284 |         obj_id = args[0]
 285 |         if self.ops.delete_object(self.current_user_id, obj_id):
 286 |             print(f"Об'єкт {obj_id} видалено")
 287 |             self.audit.log_event(EventType.DELETE_OBJECT, self.current_user_id,
 288 |                                {'object_id': obj_id})
 289 |         else:
 290 |             print("Помилка: не вдалося видалити об'єкт")
 291 |     
 292 |     def handle_list(self):
 293 |         """Обробка списку об'єктів"""
 294 |         if not self.require_auth():
 295 |             return
 296 |         
 297 |         user_objects = self.objects.get_objects_by_owner(self.current_user_id)
 298 |         if user_objects:
 299 |             print("\nВаші об'єкти:")
 300 |             for obj in user_objects:
 301 |                 print(f"  {obj['name']} ({obj['type']}) - ID: {obj['id']}")
 302 |         else:
 303 |             print("У вас немає об'єктів")
 304 |     
 305 |     def handle_take(self, args):
 306 |         """Обробка операції take"""
 307 |         if not self.require_auth():
 308 |             return
 309 |         if len(args) < 3:
 310 |             print("Використання: take <source_object> <target_object> <rights>")
 311 |             print("  rights: r,w,x,t,g,o (через кому)")
 312 |             return
 313 |         
 314 |         source = args[0]
 315 |         target = args[1]
 316 |         rights_str = args[2]
 317 |         
 318 |         # Парсинг прав
 319 |         rights = set()
 320 |         for r in rights_str.split(','):
 321 |             r = r.strip().lower()
 322 |             if r == 'r':
 323 |                 rights.add(AccessRight.READ)
 324 |             elif r == 'w':
 325 |                 rights.add(AccessRight.WRITE)
 326 |             elif r == 'x':
 327 |                 rights.add(AccessRight.EXECUTE)
 328 |             elif r == 't':
 329 |                 rights.add(AccessRight.TAKE)
 330 |             elif r == 'g':
 331 |                 rights.add(AccessRight.GRANT)
 332 |             elif r == 'o':
 333 |                 rights.add(AccessRight.OWN)
 334 |         
 335 |         if self.graph.take(self.current_user_id, source, target, rights):
 336 |             print(f"Операція take успішна: отримано права {rights_str} від {source} до {target}")
 337 |             self.audit.log_event(EventType.TAKE_OPERATION, self.current_user_id,
 338 |                                {'source': source, 'target': target, 'rights': rights_str})
 339 |         else:
 340 |             print("Помилка: операція take не вдалася")
 341 |     
 342 |     def handle_grant(self, args):
 343 |         """Обробка операції grant"""
 344 |         if not self.require_auth():
 345 |             return
 346 |         if len(args) < 3:
 347 |             print("Використання: grant <source_object> <target_subject> <rights>")
 348 |             print("  rights: r,w,x,t,g,o (через кому)")
 349 |             return
 350 |         
 351 |         source = args[0]
 352 |         target = args[1]
 353 |         rights_str = args[2]
 354 |         
 355 |         # Парсинг прав
 356 |         rights = set()
 357 |         for r in rights_str.split(','):
 358 |             r = r.strip().lower()
 359 |             if r == 'r':
 360 |                 rights.add(AccessRight.READ)
 361 |             elif r == 'w':
 362 |                 rights.add(AccessRight.WRITE)
 363 |             elif r == 'x':
 364 |                 rights.add(AccessRight.EXECUTE)
 365 |             elif r == 't':
 366 |                 rights.add(AccessRight.TAKE)
 367 |             elif r == 'g':
 368 |                 rights.add(AccessRight.GRANT)
 369 |             elif r == 'o':
 370 |                 rights.add(AccessRight.OWN)
 371 |         
 372 |         if self.graph.grant(self.current_user_id, source, target, rights):
 373 |             print(f"Операція grant успішна: надано права {rights_str} від {source} до {target}")
 374 |             self.audit.log_event(EventType.GRANT_OPERATION, self.current_user_id,
 375 |                                {'source': source, 'target': target, 'rights': rights_str})
 376 |         else:
 377 |             print("Помилка: операція grant не вдалася")
 378 |     
 379 |     def handle_check(self, args):
 380 |         """Обробка перевірки доступу"""
 381 |         if not self.require_auth():
 382 |             return
 383 |         if len(args) < 2:
 384 |             print("Використання: check <object_id> <right>")
 385 |             print("  right: r,w,x,t,g,o")
 386 |             return
 387 |         
 388 |         obj_id = args[0]
 389 |         right_str = args[1].lower()
 390 |         
 391 |         right_map = {
 392 |             'r': AccessRight.READ,
 393 |             'w': AccessRight.WRITE,
 394 |             'x': AccessRight.EXECUTE,
 395 |             't': AccessRight.TAKE,
 396 |             'g': AccessRight.GRANT,
 397 |             'o': AccessRight.OWN
 398 |         }
 399 |         
 400 |         if right_str not in right_map:
 401 |             print(f"Невідоме право: {right_str}")
 402 |             return
 403 |         
 404 |         right = right_map[right_str]
 405 |         if self.security.can_access(self.current_user_id, obj_id, right):
 406 |             print(f"Доступ до {obj_id} з правом {right_str} дозволено")
 407 |             self.audit.log_event(EventType.ACCESS_GRANTED, self.current_user_id,
 408 |                                {'object_id': obj_id, 'right': right_str})
 409 |         else:
 410 |             print(f"Доступ до {obj_id} з правом {right_str} заборонено")
 411 |             self.audit.log_event(EventType.ACCESS_DENIED, self.current_user_id,
 412 |                                {'object_id': obj_id, 'right': right_str}, success=False)
 413 |     
 414 |     def handle_admin(self, args):
 415 |         """Обробка адміністративних команд"""
 416 |         if not self.require_auth():
 417 |             return
 418 |         if not self.admin.is_admin(self.current_user_id):
 419 |             print("Помилка: ви не маєте прав адміністратора")
 420 |             return
 421 |         
 422 |         if len(args) < 1:
 423 |             print("Використання: admin <command>")
 424 |             return
 425 |         
 426 |         cmd = args[0].lower()
 427 |         
 428 |         if cmd == "list_users":
 429 |             users = self.admin.list_all_users(self.current_user_id)
 430 |             print("\nКористувачі системи:")
 431 |             for user in users:
 432 |                 is_admin = self.auth.is_admin(user)
 433 |                 print(f"  {user} {'(адміністратор)' if is_admin else ''}")
 434 |         
 435 |         elif cmd == "list_objects":
 436 |             objs = self.admin.list_all_objects(self.current_user_id)
 437 |             print("\nВсі об'єкти:")
 438 |             for obj in objs:
 439 |                 print(f"  {obj['name']} ({obj['type']}) - ID: {obj['id']}, власник: {obj['owner']}")
 440 |         
 441 |         elif cmd == "matrix":
 442 |             matrix = self.admin.get_access_matrix(self.current_user_id)
 443 |             print("\nМатриця доступу:")
 444 |             for entry in matrix:
 445 |                 rights_str = ",".join(entry['rights'])
 446 |                 print(f"  {entry['subject']} -> {entry['object']}: {rights_str}")
 447 |         
 448 |         elif cmd == "grant":
 449 |             if len(args) < 4:
 450 |                 print("Використання: admin grant <subject> <object> <rights>")
 451 |                 return
 452 |             subject = args[1]
 453 |             obj = args[2]
 454 |             rights_str = args[3]
 455 |             
 456 |             rights = set()
 457 |             for r in rights_str.split(','):
 458 |                 r = r.strip().lower()
 459 |                 if r == 'r':
 460 |                     rights.add(AccessRight.READ)
 461 |                 elif r == 'w':
 462 |                     rights.add(AccessRight.WRITE)
 463 |                 elif r == 'x':
 464 |                     rights.add(AccessRight.EXECUTE)
 465 |                 elif r == 't':
 466 |                     rights.add(AccessRight.TAKE)
 467 |                 elif r == 'g':
 468 |                     rights.add(AccessRight.GRANT)
 469 |                 elif r == 'o':
 470 |                     rights.add(AccessRight.OWN)
 471 |             
 472 |             if self.admin.grant_rights(self.current_user_id, subject, obj, rights):
 473 |                 print(f"Права {rights_str} надано {subject} до {obj}")
 474 |                 self.audit.log_event(EventType.ADMIN_ACTION, self.current_user_id,
 475 |                                    {'action': 'grant', 'subject': subject, 'object': obj})
 476 |             else:
 477 |                 print("Помилка: не вдалося надати права")
 478 |         
 479 |         else:
 480 |             print(f"Невідома адміністративна команда: {cmd}")
 481 |     
 482 |     def handle_audit(self, args):
 483 |         """Обробка команд аудиту"""
 484 |         if not self.require_auth():
 485 |             return
 486 |         
 487 |         if len(args) < 1:
 488 |             print("Використання: audit <all|failed|success>")
 489 |             return
 490 |         
 491 |         cmd = args[0].lower()
 492 |         
 493 |         if cmd == "all":
 494 |             events = self.audit.get_all_events()
 495 |             print(f"\nВсього подій: {len(events)}")
 496 |             for event in events[-20:]:  # Останні 20 подій
 497 |                 status = "✓" if event['success'] else "✗"
 498 |                 print(f"  {status} [{event['timestamp']}] {event['type']} - {event['subject']}")
 499 |         
 500 |         elif cmd == "failed":
 501 |             events = self.audit.get_failed_accesses()
 502 |             print(f"\nНеуспішні доступи: {len(events)}")
 503 |             for event in events:
 504 |                 print(f"  [{event['timestamp']}] {event['type']} - {event['subject']}")
 505 |         
 506 |         elif cmd == "success":
 507 |             events = self.audit.get_successful_operations()
 508 |             print(f"\nУспішні операції: {len(events)}")
 509 |             for event in events[-20:]:  # Останні 20 подій
 510 |                 print(f"  [{event['timestamp']}] {event['type']} - {event['subject']}")
 511 |         
 512 |         else:
 513 |             print(f"Невідома команда аудиту: {cmd}")
 514 | 

